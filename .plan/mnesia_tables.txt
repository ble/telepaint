Not sure about having some tables where there's a mem&disk version for the
incomplete murals and a disk only for the completed ones...
I wonder if there's something in between, other than writing one's own caching
system... not that mnesia would make that particularly challenging.
You could do caching prioritized by the volume of requests for a given item...
Or you could measure your _actual_ latencies, estimate

mural#{MuralHash, MuralName, ImgFetchURL, ImgHash, Rows, Columns} %more?

user#{UserHash,
      BoundHost,
      creator | {participant, Row, Column} | observer,
      LastMsgTime,
      CurrentChunkedResponse}

current_img#{ImgHash, ImgBinary} %memory & disk resident
complete_img#{ImgHash, ImgBinary %disk-only resident?

%transient
chat#{UTimeStamp,
      MuralHash,
      JSONBinary} %<--not rdbms style, bake username into JSON

%accumulator
current_chat#{MuralHash, JSONIoList} %mem & disk
complete_chat#{MuralHash, JSONIoList} %disk only?

%transient
stroke#{UTimeStamp, MuralHash, UserHash, Row, Column, JSONBinary}

%accumulator
current_strokes#{MuralHash, JSONIoList} %mem & disk
complete_stokes#{MuralHash, JSONIoList} %disk only
