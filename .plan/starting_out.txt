x Describe the general idea of the project.

x Create user story explaining generally how the app will be used.

x Add details to the user story to make it abundantly clear how interaction
  will be structured.  Err on the side of something concrete, usable, and
  quickly implemented.

x Describe the interactions possible in the client.

x Define the details of what requests will be made to the server, when,
  transmitting what, etc.

x Stub out the GET and POST requests in the web server.

o Define the cookie setting and requirements for the different requests.

o Do an experiment with chunked responses.

o Form a general idea of how the server will be implemented; a general outline
  of the interaction of http server component, mural/game creation service,
  mural FSM, player FSM, how they service the various necessary requests.

o Consider ways in which the webapp might be made partially failure tolerant,
  primarily in the form of maintaining mural & player state in distributed
  Mnesia and restarting the necessary FSMs etc. with the last good state from
  the database when a process goes missing.  (My glaring ignorance of OTP
  supervision is aching, slightly.)  Don't necessarily do anything with this,
  except perhaps consider whether this idea is feasible and what sort of
  design might make it easier or harder to add this sort of failure tolerance.

o Make the server design more concrete and implement as much of it as
  possible.

o Design the general structure of the Javascript client(s), identifying func-
  tionality common to more than one part, taking care to decouple canvas
  drawing from server-client communication from all things DOM.

o Implement and test the Javascript client for the mural creator.

o Implement and test the Javascript client for a mural participant.

o Identify what portion of the previous clients is necessary to create a
  "headless" participant client and what would need to be added.  Assume
  no browser functionality except for XMLHttpRequest (to be provided by C++
  code linked with V8) and cookies (to be provided by everyone's favorite
  module, httpc).

o Take a fucking break and draw some goofy pictures using mural.  Are you even
  going to get this far?  Who cares? :)

o Read up on port drivers in greater detail.

o Think about what behavior your crazy V8 port driver (which will provide
  XHR functionality through calling back into httpc... okay, maybe we need a
  port driver and a module or two wrapping it to provide this functionality,
  but you get the gist) will require.

o Write a trivial port driver and wrapper module that will achieve some of the
  tricky aspects of the calling back and forth:
  public wrapper api -> port driver
  port driver -> httpc
  asynchronously completing httpc -> port driver
  etc.

o Be utterly amazed if you have any clue what you are doing at this point.

o Define the structure of the V8 port driver and its wrapper code.

o Implement the port driver and test it sans wrapper code.

o Implement wrapper code.

o Wait for pigs to fly.

o Realize Spawnfest ended two months ago.
